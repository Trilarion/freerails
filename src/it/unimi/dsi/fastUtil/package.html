<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>fastUtil</title>
  </head>

  <body>

	 <P>Provides type-specialized hash maps and sets with a small memory
	 footprint and much (2 to 10 times) faster access and insertion. It is <A
	 HREF="http://www.gnu.org/philosophy/free-sw.html">free software</A>
	 distributed under the <A
	 HREF="http://www.gnu.org/copyleft/lesser.html"><ACRONYM TITLE="GNU's not
	 Unix">GNU</ACRONYM> Lesser General Public License</A>.

	 <h2>Package Specification</h2>

	 
<p>The classes of this package specialize the most useful java.util.HashSet and 
  java.util.HashMap classes to versions that accept a specific kind of key or 
  value. The general format is</p>
		<div style="padding: 1em">
		  <var>valuetype</var> <var>settype</var>
		</div>
		<p>for sets, and</p>
		<div style="padding: 1em">
		  <var>keytype</var> 2 <var>valuetype</var> <var>maptype</var>
		</div>
	 
<p>for maps.Thus, an it.unimi.dsi.fastUtil.IntHashSet stores integers efficiently, 
  whereas a it.unimi.dsi.fastUtil.Long2IntHashMap does the same for maps from 
  long integers to integers. By "type" here I mean a capitalized primitive type, 
  or java.lang.Object.</p>
<p>Since there are eight primitive types in Java, we get 269 (!) classes (some 
  nonsensical class, such as <code>Boolean2BooleanHashMap</code>, are not generated). 
  Many classes are generated just to mimic the hierarchy of java.util so to redistribute 
  common code in a similar way.</p>
	 
	 <p><b>All classes are not synchronized</b>. If multiple threads access one
	 of these classes concurrently, and at least one of the threads modifies it,
	 it must be synchronized externally. Iterators will behave unpredictably in
	 the presence of concurrent modifications.

	 <h3>Interfaces Implemented</h3>
	 
	 
<p>All maps and sets in <code>fastUtil</code> implement their standard counterpart 
  interface (e.g., java.util.Map for maps). Thus, they can be just plugged in 
  existing code, using the standard access (of course, any attempt to use the 
  wrong type for keys or values will produce a java.lang.ClassCastException). 
  However, they also provide (whenever possible) many polymorphic versions of 
  the most used methods that allow to avoid the tedious "type juggling" that is 
  well known to Java programmers. In doing so, they implement more stringent interfaces 
  that extend the standard ones.</p>
	 
	 <p>These new interfaces add some methods, which are rather obvious, and I
	 suggest you to have a look at some of them. There are just a few
	 <i>caveat</i>, mainly due to some arbitrary restriction of Java:

	 <ul>
		
		
  <li>The versions of the java.util.Map.get(Object), java.util.Map.put(Object,Object) 
    and java.util.Map.remove(Object) methods that return a primitive type cannot, 
    of course, rely on returning <code>null</code> to denote the absence of a 
    certain pair. Rather, they return a <em>default return value</em>, which is 
    set to 0 cast to the return type(or <code>false</code> for booleans) at creation, 
    but can be changed using the <code>setDefRetValue()</code> method. Note that 
    changing the default return value does not change anything about the data 
    structure; it is just a way to return a reasonably meaningful result, and 
    it can be changed at any time.</li>

		
  <li>For all maps that have object as keys, the java.util.Map.get(Object) and 
    java.util.Map#remove(Object) methods do not admit polymorphic versions, as 
    Java does not allow return-value polymorphism. Rather, the extended interfaces 
    introduce new methods of the form <code>get<var>valuetype</var>()</code> and 
    <code>remove<var>valuetype</var>()</code>. 
  <li>For the same reason, the method java.util.Collection.toArray has a polymorphic 
    version accepting a type-specific array, but there are also explicitly typed 
    methods <code>to<var>keytype</var>Array()</code>. 
</ul>

	 <h3>Additional Methods</h3>
 
	 
<p>Again, due to some limitation of Java (you cannot override covariantly the 
  return value of an interface, i.e., with a method returning a more type-specific 
  value) there are some features of <code>fastUtil</code> that are available only 
  by means of type casting. In particular, keys and values of a map are of the 
  <code>fastUtil</code> type you expect (e.g., the keys of an it.unimi.dsi.fastUtil.Int2LongMap 
  are an it.unimi.dsi.fastUtil.IntSet and the values are a it.unimi.dsi.fastUtil.LongCollection), 
  but you must explicitly cast the objects returned by java.util.Map#keySet()and 
  java.util.Map#values() to the appropriate type. 
<p>Similarly, all iterators have a suitable method <code>next<var>type</var>()</code> 
  returning directly a primitive type: however, you must cast explicitly the object 
  returned by java.util.Set#iterator() to the appropriate type (e.g., it.unimi.dsi.fastUtil.CharIterator 
  for a it.unimi.dsi.fastUtil.CharSet). 
<p>Finally, there are constructors that allows you to build easily a set
	 from an array. This means, for instance, that you can create quickly a set
	 of strings with a statement like 
					 <blockquote>
					 <code>new ObjectHashSet(new String[] { "foo", "bar" })</code>
					 </blockquote>

	
	 <h2>Performance</h2>
	 
	 <p>The main reason behind <code>fastUtil</code> is performance, both in
	 time and in space. The relevant methods are something like 2 to 10 times
	 faster than those of the standard classes. 

	 <p><code>fastUtil</code> reduces enormously the creation and collection of
	 objects. First of all, if you use the polymorphic methods and iterators no
	 wrapper objects have to be created. Moreover, since <code>fastUtil</code>
	 uses open addressing, creation and garbage collection of table entries are
	 avoided (but tables have to be rehashed whenever they are filled
	 beyond the load factor).

    <p>Whenever possible, <code>fastUtil</code> tries to gain some speed by
    checking for faster interfaces: for instance, the various set-theoretic
    methods <code>addAll()</code>, <code>retainAll()</code>, ecc. check whether
    their arguments are type-specific and use faster iterators and accessors
    accordingly.
	 

	 <h2>Deletions</h2>

	 <p>Since deletions are handled simply by tagging, they are very fast <i>per
	 se</i>, but they tend to slow down subsequent accesses (with respect to a
	 set with no deleted entries). In highly dynamical situations, where entries
	 are continuously created and deleted, unsuccessful searches may take linear
	 time (as <em>all</em> entries must be probed).

	 <p>A partial solution to this problem (which has no known complete solution
	 if you use open addressing with double hashing&mdash;cfr. Knuth's
	 section on hashing in the third volume of <em>The Art of Computer
	 Programming</em>) is to call the <code>rehash()</code> method, which will
	 try to rebuild the table remapping all keys.

	 <p>In other words, if your application requires inextricably interleaved
	 insertions, deletions and queries open-addressing implementations (and in
	 particular <code>fastUtil</code> classes) are not the right choice.

	 
<p>Note, however, that <code>fastUtil</code> implements a special optimization, 
  usually not found elsewhere, that greatly speeds up probes for recently deleted 
  entries. More details can be found in the documentation of the it.unimi.dsi.fastUtil.Hash 
  interface. 
<h2>Memory Usage</h2>

	 
<p>To avoid memory waste, the classes in <code>fastUtil</code> keep no additional 
  information about elements (such as a list of keys). In particular, this means 
  that enumerations are always linear in the size of the table (rather than in 
  the number of keys). In general, this would imply slower iterators. Nonetheless, 
  the iterator code includes a single, tight loop; moreover, it is possible to 
  avoid the creation of wrappers. These two facts make in practice <code>fastUtil</code> 
  iterators <em>faster</em> than java.util's. 
<p>The memory footprint for a table with <var>n</var> keys is exactly the
	 memory required for the related types times <var>n</var> bytes, plus a
	 overhead of <var>n</var> bytes to store the state of each entry. The
	 absence of wrappers around primitive types can reduce space occupancy by
	 several times (this applies even more to serialized data, e.g., when you
	 save such a data structure in a file).  These data can greatly vary with
	 your virtual machine, JVM versions, CPU etc.

	 
<p>More precisely, when you ask for a map that will hold <var>n</var> elements 
  with load factor 0&lt;<var>f</var>&le;1, <var>p</var> entries are allocated, 
  where <var>p</var> is first prime in it.unimi.dsi.fastUtil.Hash#primes larger 
  than <var>n</var>/<var>f</var>. Primes in it.unimi.dsi.fastUtil.Hash#primes 
  are roughly multiplicatively spaced by 2<sup>1/16</sup>, so you lose on average 
  about 2% with respect to <var>n</var>/<var>f</var>. When the table is filled 
  up beyond the load factor, it is rehashed to a roughly doubled size. 
<p>An important downside of this design is that <em>hash codes are not
	 cached</em>. Thus, you should not use <code>fastUtil</code> classes with
	 keys having slow equality methods, as a probe requires testing equality
	 with all keys met along the probe sequence.

	 <h2>Robustness</h2>
	 
	 <p>The code in <code>fastUtil</code> has passed intensive regression
	 tests. You can trust it much in the same way you trust the standard
	 classes.</p>

  </body>
</html>
