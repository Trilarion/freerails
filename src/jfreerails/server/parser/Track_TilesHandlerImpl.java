/*
 * Date:           21 January 2002  18:00
 *
 */
package jfreerails.server.parser;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

import jfreerails.world.terrain.TerrainType;
import jfreerails.world.top.SKEY;
import jfreerails.world.top.World;
import jfreerails.world.track.LegalTrackPlacement;
import jfreerails.world.track.TrackRule;
import jfreerails.world.track.TrackRuleImpl;
import jfreerails.world.track.TrackRuleProperties;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

/**
 * Processes Track_TilesHandle events, generates track rules, and provides a
 * methods to add the track rules to the world object.
 * 
 * @author lindsal
 * @version generated by FFJ XML module
 * @see Track_TilesParser
 */
public class Track_TilesHandlerImpl implements Track_TilesHandler {
	int maxConsequ;

	protected List<TrackRule> ruleList;

	protected jfreerails.world.track.TrackRuleProperties trackRuleProperties;

	protected jfreerails.world.track.LegalTrackConfigurations legalTrackConfigurations;

	protected ArrayList<String> legalTemplates;

	protected HashSet<TerrainType.Category> terrainTypes;

	protected LegalTrackPlacement legalTrackPlacement;

	public void start_CanOnlyBuildOnTheseTerrainTypes(final Attributes meta)
			throws SAXException {
		terrainTypes = new HashSet<TerrainType.Category>();
	}

	public void end_CanOnlyBuildOnTheseTerrainTypes() throws SAXException {
		legalTrackPlacement = new LegalTrackPlacement(terrainTypes,
				LegalTrackPlacement.PlacementRule.ONLY_ON_THESE);
		terrainTypes = null;
	}

	public void start_ListOfTrackPieceTemplates(final Attributes meta)
			throws SAXException {
		legalTemplates = new ArrayList<String>();
	}

	public void end_ListOfTrackPieceTemplates() throws SAXException {
		legalTrackConfigurations = new jfreerails.world.track.LegalTrackConfigurations(
				maxConsequ, legalTemplates);
		legalTemplates = null;
	}

	public void start_ListOfLegalRoutesAcrossNode(final Attributes meta)
			throws SAXException {
	}

	public void end_ListOfLegalRoutesAcrossNode() throws SAXException {
	}

	public void handle_LegalRouteAcrossNode(final Attributes meta)
			throws SAXException {
	}

	public void start_CannotBuildOnTheseTerrainTypes(final Attributes meta)
			throws SAXException {
		terrainTypes = new java.util.HashSet<TerrainType.Category>();
	}

	public void end_CannotBuildOnTheseTerrainTypes() throws SAXException {
		legalTrackPlacement = new LegalTrackPlacement(terrainTypes,
				LegalTrackPlacement.PlacementRule.ANYWHERE_EXCEPT_ON_THESE);
		terrainTypes = null;
	}

	public void start_TrackType(final Attributes meta) throws SAXException {
		int rGBvalue;
		String rgbString = meta.getValue("RGBvalue");
		rGBvalue = Integer.parseInt(rgbString, 16);

		/*
		 * We need to change the format of the rgb value to the same one as used
		 * by the the BufferedImage that stores the map. See
		 * jfreerails.common.Map
		 */
		rGBvalue = new java.awt.Color(rGBvalue).getRGB();

		TrackRule.TrackCategories category = TrackRule.TrackCategories
				.valueOf(meta.getValue("category"));

		boolean enableDoubleTrack = Boolean.valueOf(
				meta.getValue("doubleTrack")).booleanValue();
		String typeName = meta.getValue("type");
		maxConsequ = Integer.parseInt(meta.getValue("maxConsecuativePieces"));

		String stationRadiusString = meta.getValue("stationRadius");
		int stationRadius;

		if (null != stationRadiusString) {
			stationRadius = Integer.parseInt(stationRadiusString);
		} else {
			stationRadius = 0;
		}

		String priceString = meta.getValue("price");
		int price = Integer.parseInt(priceString);

		String fixedCostString = meta.getValue("fixedCost");
		int fixedCost;

		if (null != fixedCostString) {
			fixedCost = Integer.parseInt(fixedCostString);
		} else {
			fixedCost = 0;
		}

		String maintenanceString = meta.getValue("maintenance");
		int maintenance = Integer.parseInt(maintenanceString);

		trackRuleProperties = new TrackRuleProperties(rGBvalue,
				enableDoubleTrack, typeName, category, stationRadius, price,
				maintenance, fixedCost);
	}

	public void end_TrackType() throws SAXException {
		TrackRuleImpl trackRuleImpl = new jfreerails.world.track.TrackRuleImpl(
				trackRuleProperties, legalTrackConfigurations,
				legalTrackPlacement);
		ruleList.add(trackRuleImpl);

		legalTrackConfigurations = null;
		trackRuleProperties = null;
		legalTrackPlacement = null;
	}

	public void handle_TerrainType(final Attributes meta) throws SAXException {
		TerrainType.Category cat = TerrainType.Category.valueOf(meta
				.getValue("name"));
		terrainTypes.add(cat);
	}

	public void start_Tiles(final Attributes meta) throws SAXException {
	}

	public void end_Tiles() throws SAXException {
		// Sort the track tiles by category then price.
		Collections.sort(ruleList);
	}

	public void start_TrackPieceTemplate(final Attributes meta)
			throws SAXException {
		legalTemplates.add(meta.getValue("trackTemplate"));
	}

	public void end_TrackPieceTemplate() throws SAXException {
		// do nothing.
	}

	public void start_TrackSet(final Attributes meta) throws SAXException {
		ruleList = new ArrayList<TrackRule>();
	}

	public void end_TrackSet() throws SAXException {
	}

	public Track_TilesHandlerImpl(java.net.URL trackXmlUrl) {
		try {
			Track_TilesParser.parse(trackXmlUrl, this);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

    public void addTrackRules(World w) {
        for (int i = 0; i < this.ruleList.size(); i++) {
            TrackRule r = ruleList.get(i);
            w.add(SKEY.TRACK_RULES, r);
        }
    }

	public List<TrackRule> getRuleList() {
		return ruleList;
	}
}